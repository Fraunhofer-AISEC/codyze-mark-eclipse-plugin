package botan


entity Botan::Cipher_Mode isa Cipher {
	
	var algorithm : cpp:std::String;  // TODO cpp weglassen
	var direction : cpp:Botan::Cipher_Dir; // an enum of underlying type int
	var provider : cpp:std::String;
	var key : cpp:Botan::SymmetricKey; // aka Botan::OctetString; class wrapping Botan::secure_vector<T, secure_allocator<T>>; secure_vector<> scrubs memory on deallocate()
	var iv : cpp:Botan::InitializationVector; // aka Botan::OctetString; class wrapping Botan::secure_vector<T, secure_allocator<T>>; secure_vector<> scrubs memory on deallocate()
	var input : _;  // e.g. Botan::secure_vector<uint8_t>   // TODO Wildcards nur als _ möglich
	var input_length : cpp:std::size_t;
	
	op create(algorithm) {
		/*
		 * method call(s):
		 * - static std::unique_ptr<Cipher_Mode> create(const std::string& algo, Cipher_Dir direction, const std::string& provider = "")
		 * - static std::unique_ptr<Cipher_Mode> create_or_throw(const std::string& algo, Cipher_Dir direction, const std::string& provider = "")
		 * 
		 * function call(s):
		 * - Cipher_Mode* get_cipher_mode(const std::string& algo_spec, Cipher_Dir direction, const std::string& provider = "")
		 */
		call Botan::get_cipher_mode(algorithm, direction);
		call Botan::get_cipher_mode(algorithm, direction, provider);

		/* this is only for botan version >= 2.6.0  
		call Botan::Cipher_Mode::create(algorithm, direction);
		call Botan::Cipher_Mode::create(algorithm, direction, provider);
	
		call Botan::Cipher_Mode::create_or_throw(algorithm, direction);
		call Botan::Cipher_Mode::create_or_throw(algorithm, direction, provider); 
		*/
	}
	
	op init() {
		/*
		 * method call(s) inherited from Botan::SymmetricAlgorithm:
		 * - void set_key(const SymmetricKey& key)
		 * - template<typename Alloc>
		 *   void set_key(const std::vector<uint8_t, Alloc>& key)
		 * - void set_key(const uint8_t key[], size_t length);
		 */
		call Botan::Cipher_Mode::set_key(key);
		//forbidden call Botan::Cipher_Mode::set_key(const uint8_t[], size_t)
	}
	
	op start() {
		/* 
		 * method call(s):
		 * - template<typename Alloc>
		 *   void start(const std::vector<uint8_t, Alloc>& nonce)
		 * - void start(const uint8_t nonce[], size_t nonce_len)
		 * - void start()
		 * 
		 * - virtual void start_msg(const uint8_t nonce[], size_t nonce_len) = 0;
		 */
    	// forbidden: call Botan::Cipher_Mode::start();
		call Botan::Cipher_Mode::start(iv);
		// forbidden: call Botan::Cipher_Mode::start(const uint8_t[], size_t);
		// forbidden: call Botan::Cipher_Mode::start_msg(const uint8_t[], size_t);
	}
	
	op process() {
		/*
		 * method call(s): 
		 * - void update(secure_vector<uint8_t>& buffer, size_t offset = 0)
		 * 
		 * - virtual size_t process(uint8_t msg[], size_t msg_len) = 0;
		 */
		call Botan::Cipher_Mode::process(input, input_length);
		
		call Botan::Cipher_Mode::update(input);
		call Botan::Cipher_Mode::update(input, input_length);
	}
	
	op finish() {
		/*
		 * method call(s):
		 * - virtual void finish(secure_vector<uint8_t>& final_block, size_t offset = 0) = 0;
		 */
		call Botan::Cipher_Mode::finish(input);
		call Botan::Cipher_Mode::finish(input, size_t);  // TODO keine Typen in Signatur, nur Variablen (oder ggf. Wildcard _)
	}
	
	op reset() {
		/*
		 * method call(s):
		 * - virtual void reset() = 0;
		 */
		call Botan::Cipher_Mode::reset();
	}
	
	order create, init, start, /*process*,*/ finish, reset?;
	
}


rule BlockCiphers {
	for Botan::Cipher_Mode 
	ensure
		_split(algorithm, "/", 0) in [ "AES" ]  // TODO Nicetohave: Vordefinierte Methoden highlighten
	onfail WrongBlockCipher
}

rule UseRandomIV {
	for Botan::Cipher_Mode as myCipherMode,
		Botan::AutoSeededRNG as myRng        // TODO Namens-Alias mit "as"
	when _split(algorithm, "/", 1) == "CBC" && myCipherMode.direction == Botan::Cipher_Dir::ENCRYPTION
	ensure
		_receives_value_from(myCipherMode.iv, myRng.myValue)  // TODO "def" trifft es hier nicht ganz. Es geht genaugenommen nicht um die Definition der Variablen, sondern um *alle möglichen* Werte, die sie zur Laufzeit annehmen kann.
	onfail NoRandomIV
}


//rule OnlyAES_256 {
//	for Botan_CipherMode
//	when _part(1, "/", algorithm) == "AES"
//	ensure
//		_length(key) == 256
//}
