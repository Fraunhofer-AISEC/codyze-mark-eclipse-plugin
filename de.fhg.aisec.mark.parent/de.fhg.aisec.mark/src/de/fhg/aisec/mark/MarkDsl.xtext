/**
 * This is the ANTLR/Xtext grammar definition for the MARK domain specific language. 
 */
grammar de.fhg.aisec.mark.MarkDsl with org.eclipse.xtext.common.Terminals

//import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate markDsl "http://www.fhg.de/aisec/mark/MarkDsl"

MarkModel:
	package=PackageClause
	imports+=ImportDeclaration*
	decl+=EntityDeclaration*
	orders+=OrderExpression*
	rule+=RuleDeclaration*
	functions+=FunctionExpression*
	evidence+=EvidenceDeclaration*
	oids+=ObjectIdentifier*
//	msg+=MessageDeclaration*
;

PackageClause:
	'package' name=QualifiedName;

ImportDeclaration:
	'import' name=QualifiedName;

EntityDeclaration:
	'entity' name=QualifiedName ('isa' superType=[EntityDeclaration])? '{' (content+=(VariableDeclaration | AssertionDeclaration | OpDeclaration | OrderExpression))* '}';

VariableDeclaration:
	'var' name=ID (':' type=Type)? ('=' init=InitializerExpression | 'where' where=WhereExpression)? ';';

AssertionDeclaration:
    'assert' exp=Expression 'onfail' msg=ID ';'
;

InitializerExpression:
	Literal | List;

List:
	{List} '[' items=LiteralList? ']';

WhereExpression:
	exp=Expression (emit=Emitter)?;

Emitter:
	('error' | 'warning' | 'info') ID
;

QualifiedName:
	ID
	| JavaQualifiedName
	| CppQualifiedName
;
	
JavaQualifiedName:
    ID ('.' ID)+
;

CppQualifiedName:
    ID ('::' ID)+ 
;

Type:
	TypeName | 
	TypeLiteral |
	'(' Type ')'
;

TypeName:
	BuiltinType 
	| JavaType 
	| CppType
;

BuiltinType:
	'uint' | 'int' | 'bool' | 'string';

TypeLiteral:
	ListType;

ListType:
	'[]' Type;



Expression:
	LogicalOrExpression
;

LogicalOrExpression returns Expression:
	LogicalAndExpression ({LogicalOrExpression.left=current} op=('||') right=LogicalAndExpression)*
;

LogicalAndExpression returns Expression:
	ComparisonExpression ({LogicalAndExpression.left=current} op=('&&') right=ComparisonExpression)*
;

ComparisonExpression returns Expression:
	AdditionExpression ({ComparisonExpression.left=current} op=('=='|'!='|'<'|'<='|'>'|'>='|'in'|'like') right=AdditionExpression)*
;

AdditionExpression returns Expression:
	MultiplicationExpression ({AdditionExpression.left=current} op=('+'|'-'|'|'|'^') right=MultiplicationExpression)*
;

MultiplicationExpression returns Expression:
	PrimaryExpression ({MultiplicationExpression.left=current} op=('*'|'/'|'%'|'<<'|'>>'|'&'|'&^') right=PrimaryExpression)*
;

/* 
 * This is a little hack to avoid superfluous UnaryExpression nodes in the EObject AST. 
 * Now, UnaryExpression nodes are generated only if a unary operator is detected. 
 * In addition, we prevent expressions like '!!a'. 
 */
PrimaryExpression returns Expression:
	UnaryExpression
	| SimplifiedPrimaryExpression
;

UnaryExpression:
    op=('+'|'-'|'!'|'^') exp=SimplifiedPrimaryExpression 
;

SimplifiedPrimaryExpression returns Expression:
    Literal 
    | Operand 
    | '(' LogicalOrExpression ')'
;

Operand:
    {Operand} operand=OperandName
;

OperandName:
    QualifiedName
;



/*
 * Grammar rules to specify the order of actions/events/operations
 */

OrderExpression:
    {OrderExpression} 'order' exp=SequenceExpression ';'
;


SequenceExpression returns OrderExpression:
    AlternativeExpression ({SequenceExpression.left=current} op=',' right=AlternativeExpression)*
;

AlternativeExpression returns OrderExpression:
    TermExpression ({AlternativeExpression.left=current} op='|' right=TermExpression)*
;


ExclusionExpression:
    op='!' exp=SimplifiedTermExpression
;

RepetitionExpression returns OrderExpression:
    SimplifiedTermExpression ({RepetitionExpression.expr=current} op=('?'|'*'|'+'))?
;

TermExpression returns OrderExpression:
    ExclusionExpression
    | RepetitionExpression
;


GroupingExpression returns OrderExpression:
    '(' SequenceExpression ')'
;

SimplifiedTermExpression returns OrderExpression:
    Terminal
    | GroupingExpression
;


Terminal:
    {Terminal} t=ID
;



FunctionExpression:
    name=QualifiedName '(' (params+=FunctionParameter (',' params+=FunctionParameter)*)? ')'
;

FunctionParameter:
    name=ID
;

//Statement:
////	LetStmt | UsingStmt | 
//	TypeDeclarationStmt;
//
//	//LetStmt:
////	'LET' name=ID '=' expression=Sequence;
////
////UsingStmt:
////	'USING' name=[LetStmt] 'ENSURE' 'THAT' invariant=STRING 'REASON' reason=STRING // TODO invariant
////;
//
////Sequence:
////	headTerm=TraversalTerm ('->' tailTerms+=TraversalTerm)*;
////
////TraversalTerm:
////	name=ID '(' parameters=ArgumentList? ')';
////
////ArgumentList:
////	head=ID (',' tail+=ID)*;
//TypeDeclarationStmt:
//	name=ID ('isa' superType=ID)? '{' (content+=ID)* '}';
//
//	//Type:
////	name=ID;


RuleDeclaration:
	'rule' name=QualifiedName '{' stmt=RuleStatement '}'
;

RuleStatement:
	'using' e=[EntityDeclaration] 'ensure' exp=LogicalOrExpression 'onfail' msg=ID ';'?
;


EvidenceDeclaration:
    'evidence' name=[EntityDeclaration] '{' (stmts+=EvidenceStatement ';')+ '}'
;

EvidenceStatement:
    CallStatement | DeclarationStatement | ImportStatement
;

CallStatement:
    'call' (res=ID '=')? call=FunctionExpression ('where' cond=WhereExpression)?
;

DeclarationStatement:
    'decl' (res=ID '=')? decl=QualifiedName
;

ImportStatement:
    'incl' name=(ID | JavaImport | CppInclude)
;

JavaImport:
    ID ('.' ID)+
;

CppInclude:
    ID ('/' ID)+ ('.' ID)?
;


OpDeclaration:
    'op' name=ID '(' (params+=ID (',' params+=ID)*)? ')' '{' (stmts+=OpStatement)* '}'
;

OpStatement:
    (CallStatement | DeclarationStatement | ImportStatement) ';'
;

//MessageDeclaration:
//	'message' name=QualifiedName '{' msg=MessageStatement '}'
//;
//
//MessageStatement:
//	s=MessageSeverity
//	l=MessageLanguage?
//	c=MessageContent	
//;
//
//MessageSeverity:
//	'severity' severity=('error'|'warning'|'info'|'debug') ';'
//;
//
//MessageLanguage:
//	'lang' language=ID ';' 
//;
//
//MessageContent:
//	'content' content=StringLiteral ';'
//;

ObjectIdentifier:
    ('OID.')? INT ('.' INT)*
;

JavaType:
    'java:' JavaQualifiedName
;

CppType:
    'cpp:' CppQualifiedName
;


LiteralList:
	lit+=Literal (',' lit+=Literal)*
;

Literal:
	{IntegerLiteral} value=IntegerLiteral 
	| {FloatingPointLiteral} value=FloatingPointLiteral 
	| {BooleanLiteral} value=BooleanLiteral 
	| {CharacterLiteral} value=CharacterLiteral 
	| {StringLiteral} value=StringLiteral
;


IntegerLiteral:
	INT	
	| HEX
;

FloatingPointLiteral:
	INT '.' INT
;
	
BooleanLiteral:
	'true' 
	| 'false'
;
	
CharacterLiteral:
	CHARACTER
;

StringLiteral:
	STRING
;



// Tokens 

terminal HEX:
	'0x' (HEX_DIGIT)+
;

@Override
terminal STRING:
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|'\''|'\\') | !('\\'|'"') )* '"'
;

terminal CHARACTER:
	'\'' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|'\''|'\\') | !('\\'|'\'') )? '\''
;

terminal fragment HEX_DIGIT:
	DIGIT 
	| 'a'..'f' 
	| 'A'..'F'
;

terminal fragment DIGIT:
	'0' 
	| NONZERO_DIGIT
;

terminal fragment NONZERO_DIGIT:
	'1'..'9'
;

