/**
 * This is the ANTLR/Xtext grammar definition for the MARK domain specific language. 
 */
grammar de.fhg.aisec.mark.MarkDsl with org.eclipse.xtext.common.Terminals

//import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate markDsl "http://www.fhg.de/aisec/mark/MarkDsl"

MarkModel:
	package=PackageClause
	imports+=ImportDeclaration*
	decl+=EntityDeclaration*
	rule+=RuleDeclaration*
//	msg+=MessageDeclaration*
;

PackageClause:
	'package' name=QualifiedName;

ImportDeclaration:
	'import' name=QualifiedName;

EntityDeclaration:
	'entity' name=ID ('isa' superType=[EntityDeclaration])? '{' (content+=VariableDeclaration)* '}';

VariableDeclaration:
	'var' name=ID (":" type=Type)? ("=" init=InitializerExpression | "where" where=WhereExpression)? ";";

InitializerExpression:
	Literal | List;

List:
	{List} "[" items=LiteralList? "]";

WhereExpression:
	exp=Expression (emit=Emitter)?;

Emitter:
	('error' | 'warning' | 'info') ID
;

QualifiedName:
	ID (=> '.' ID)*;

Type:
	TypeName | 
	TypeLiteral |
	'(' Type ')'
;

TypeName:
	BasicType |
	QualifiedName
;

BasicType:
	"uint" | "int" | "bool";

TypeLiteral:
	ListType;

ListType:
	"[]" Type;

Expression:
	LogicalOrExpression
;
//	TerminalExpression ({Operation.left=current} op="+" right=TerminalExpression)*;
//
//TerminalExpression returns Expression:
//	"(" Expression ")" | Literal;


//Expression
//    : UnaryExpr
////    | expression BINARY_OP expression
//    | Expression ('||' | '&&' | '==' | '!=' | '<' | '<=' | '>' | '>=' | '+' | '-' | '|' | '^' | '*' | '/' | '%' | '<<' | '>>' | '&' | '&^') Expression
//    ;
//
//UnaryExpr
//    : primaryExpr
//    | ('+'|'-'|'!'|'^'|'*'|'&'|'<-') unaryExpr
//;


LogicalOrExpression returns Expression:
	LogicalAndExpression ({LogicalOrExpression.left=current} op='||' right=LogicalAndExpression)*
;


LogicalAndExpression returns Expression:
	ComparisonExpression ({LogicalAndExpression.left=current} op='&&' right=ComparisonExpression)*
;

ComparisonExpression returns Expression:
	AdditionExpression ({ComparisonExpression.left=current} op=('=='|'!='|'<'|'<='|'>'|'>=') right=AdditionExpression)*
;

AdditionExpression returns Expression:
	MultiplicationExpression ({AdditionExpression.left=current} op=('+'|'-'|'|'|'^') right=MultiplicationExpression)*
;

MultiplicationExpression returns Expression:
	PrimaryExpression ({MultiplicationExpression.left=current} op=('*'|'/'|'%'|'<<'|'>>'|'&'|'&^') right=PrimaryExpression)*
;

UnaryExpression returns Expression:
	{UnaryExpression} op=('+'|'-'|'!'|'^'|'*'|'&'|'<-') exp=PrimaryExpression 
;


PrimaryExpression returns Expression:
	Literal |
	QualifiedName ('.' Type)? |
	UnaryExpression | 
	'(' LogicalOrExpression ')'
;


//BinaryOperator:
//	"and" | "or";
//
//Statement:
////	LetStmt | UsingStmt | 
//	TypeDeclarationStmt;
//
//	//LetStmt:
////	'LET' name=ID '=' expression=Sequence;
////
////UsingStmt:
////	'USING' name=[LetStmt] 'ENSURE' 'THAT' invariant=STRING 'REASON' reason=STRING // TODO invariant
////;
//
////Sequence:
////	headTerm=TraversalTerm ('->' tailTerms+=TraversalTerm)*;
////
////TraversalTerm:
////	name=ID '(' parameters=ArgumentList? ')';
////
////ArgumentList:
////	head=ID (',' tail+=ID)*;
//TypeDeclarationStmt:
//	name=ID ('isa' superType=ID)? '{' (content+=ID)* '}';
//
//	//Type:
////	name=ID;


RuleDeclaration:
	'rule' name=QualifiedName '{' stmt=RuleStatement '}'
;

RuleStatement:
	'using' e=[EntityDeclaration] 'ensure' exp=LogicalOrExpression 'onfail' msg=ID ';'?
;


//MessageDeclaration:
//	'message' name=QualifiedName '{' msg=MessageStatement '}'
//;
//
//MessageStatement:
//	s=MessageSeverity
//	l=MessageLanguage?
//	c=MessageContent	
//;
//
//MessageSeverity:
//	'severity' severity=('error'|'warning'|'info'|'debug') ';'
//;
//
//MessageLanguage:
//	'lang' language=ID ';' 
//;
//
//MessageContent:
//	'content' content=StringLiteral ';'
//;


LiteralList:
	lit+=Literal (',' lit+=Literal)*;

Literal:
	{IntegerLiteral} value=IntegerLiteral | 
	{FloatingPointLiteral} value=FloatingPointLiteral | 
	{BooleanLiteral} value=BooleanLiteral | 
	{CharacterLiteral} value=CharacterLiteral | 
	{StringLiteral} value=StringLiteral
;

IntegerLiteral:
	INT | HEX;

FloatingPointLiteral:
	INT '.' INT;
	
BooleanLiteral:
	'true' | 'false';
	
CharacterLiteral:
	CHARACTER;

StringLiteral:
	STRING;


terminal HEX:
	'0x' (HEX_DIGIT)+;

@Override
terminal STRING:
	'"' ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|'"') )* '"';

terminal CHARACTER:
	"'" ( '\\' ('b'|'t'|'n'|'f'|'r'|'"'|"'"|'\\') | !('\\'|"'") )? "'";

terminal fragment HEX_DIGIT:
	DIGIT | 'a'..'f' | 'A'..'F';

terminal fragment DIGIT:
	'0' | NONZERO_DIGIT;

terminal fragment NONZERO_DIGIT:
	'1'..'9';

